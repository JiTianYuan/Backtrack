# Backtrack

### 插桩
方法名映射id存储到mapping文件
编译期将mapping文件保存到assert目录下
适配插件化：不同的插件有不同的mapping，方法id冲突问题，mapping合并问题
idea1：mapping不合并，所有插件下的mapping文件都存入文件夹。导出时将整个文件夹导出，然后统一处理
    以后可以线上使用，上线时mapping不放到assets目录下

idea2：数据存储时，直接读取mapping，存储真实的类名信息
    不适合未来线上使用

### 采集数据

### 丢弃数据

### 保存数据

### 帧监控

### 回溯栈数据结构：
数组储存，有一个初始长度，长度不足就扩容
数组有两个，一个数组记录出入栈+时间，另一个数组记录方法id：
数组1：long类型，64位，第一位表示入栈还是出栈，后63位表示时间（精确到微秒）
数组2：int类型，保存方法id
所以，一个方法入栈占用96位，12字节。
假设：初始化栈深度1024，占用12kb

问题：初始化栈深度多少合适？
需要计算一帧大概会有多少的深度。然后考虑到丢帧和ANR的情况，计算一下5秒需要多少深度


### 线程问题：只记录主线程，其他线程不记录。

### 数据的可视化
借用google的Perfetto工具，生成的数据按照规则去写，就可以生成可以被Perfetto识别的文件
生成一条最简易的方法执行开始和结束的记录，格式如下：
```
<包名-线程id>  ( <线程id>) [000] .... <时间>: tracing_mark_write: <B或者E>|<进程ID>|<TAG>
```
记录VSYNC信号：（0和1来回切换）
```
<包名-线程id>  ( <线程id>) [000] .... <时间>: tracing_mark_write: C|<进程ID>|VSYNC-app|0
```



